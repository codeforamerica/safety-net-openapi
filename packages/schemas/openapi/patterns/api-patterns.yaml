# API Design Patterns Configuration
# This file defines the patterns and conventions for all APIs in this project.
# Used by: validation scripts, template generators, and AI agents.

version: "1.0"

# =============================================================================
# Pattern Applicability
# =============================================================================
# This project has two API layers (see docs/architecture/domain-design.md):
#
# SYSTEM APIs: RESTful CRUD access to domain data
#   - Example: GET /tasks/{id}, POST /applications, PATCH /cases/{id}
#   - Located in: openapi/domains/
#
# PROCESS APIs: RPC-style orchestration of business operations
#   - Pattern: POST /processes/{domain}/{resource}/{action}
#   - Example: POST /processes/workflow/tasks/claim
#   - Located in: openapi/processes/{domain}/{resource}/{action}.yaml
#
# Each section below indicates which API type it applies to:
#   [SYSTEM]         - System APIs only
#   [PROCESS]        - Process APIs only
#   [BOTH]           - Both API types
#   [SYSTEM, PROCESS*] - Required for System, optional/varies for Process

# =============================================================================
# Naming Conventions [BOTH]
# =============================================================================
naming:
  # URL path segments: kebab-case (lowercase with hyphens)
  # System API example: /user-profiles, /order-items
  # Process API example: /processes/applications/submit
  paths: kebab-case

  # Path parameters: camelCase inside braces
  # Example: /users/{userId}, /orders/{orderId}
  path_parameters: camelCase

  # Query parameters: camelCase
  # Example: ?pageSize=10, ?sortOrder=desc
  query_parameters: camelCase

  # Operation IDs: camelCase verb + noun
  # System API example: listPersons, createApplication, getHouseholdById
  # Process API example: submitApplication, determineEligibility, reassignTasks
  operation_ids: camelCase

  # Schema/component names: PascalCase
  # System API example: Person, ApplicationCreate, HouseholdList (resource schemas)
  # Process API example: SubmitApplicationRequest, SubmitApplicationResponse (DTOs)
  schemas: PascalCase

  # File names: kebab-case
  # Example: user-profiles.yaml, common-parameters.yaml
  files: kebab-case

# =============================================================================
# List Endpoint Pattern [SYSTEM]
# =============================================================================
# Process APIs do not have list endpoints - they perform actions, not queries.
list_endpoints:
  # All list endpoints (GET /resources) must include these parameters
  required_parameters:
    - ref: "./components/common-parameters.yaml#/SearchQueryParam"
      name: q
      description: Search query using field:value syntax
    - ref: "./components/common-parameters.yaml#/LimitParam"
      name: limit
      description: Maximum items to return (1-100, default 25)
    - ref: "./components/common-parameters.yaml#/OffsetParam"
      name: offset
      description: Number of items to skip (default 0)

  # Response schema must include these properties
  response:
    required_properties:
      - name: items
        type: array
        description: Array of resources
      - name: total
        type: integer
        description: Total number of matching resources
      - name: limit
        type: integer
        description: Requested limit value
      - name: offset
        type: integer
        description: Requested offset value
    recommended_properties:
      - name: hasNext
        type: boolean
        description: Whether more results exist beyond current page

  # Response schema naming: {Resource}List
  # Example: PersonList, ApplicationList
  response_schema_suffix: List

# =============================================================================
# Search Query Syntax [SYSTEM]
# =============================================================================
# Process APIs do not use search - they receive explicit request payloads.
search_syntax:
  parameter_name: q
  description: |
    Search query using field:value syntax. Multiple conditions separated by
    spaces are ANDed together.

  operators:
    - pattern: "term"
      description: Full-text search across all searchable fields
      example: "john"
    - pattern: "field:value"
      description: Exact match on field
      example: "status:approved"
    - pattern: "field:>value"
      description: Greater than
      example: "income:>1000"
    - pattern: "field:>=value"
      description: Greater than or equal
      example: "income:>=1000"
    - pattern: "field:<value"
      description: Less than
      example: "income:<5000"
    - pattern: "field:<=value"
      description: Less than or equal
      example: "income:<=5000"
    - pattern: "field:val1,val2"
      description: Match any value (OR)
      example: "status:approved,pending"
    - pattern: "-field:value"
      description: Exclude/negate
      example: "-status:denied"
    - pattern: "field:*"
      description: Field exists (not null)
      example: "email:*"
    - pattern: "field.nested:value"
      description: Nested field using dot notation
      example: "address.state:CA"

# =============================================================================
# CRUD Operations [SYSTEM]
# =============================================================================
# Process APIs are RPC-style (POST with action verbs), not RESTful CRUD.
# Process API pattern: POST /processes/{domain}/{resource}/{action}
# Example: POST /processes/workflow/tasks/claim, POST /processes/case-management/workers/assign
crud_operations:
  # CREATE - POST /resources
  create:
    method: POST
    path_pattern: "/{resources}"
    success_response:
      code: 201
      description: Resource created successfully
      headers:
        - name: Location
          description: URL of the newly created resource
          format: uri
      body: Created resource object
    error_responses: [400, 422, 500]
    request_body:
      required: true
      schema_suffix: Create
      description: "Payload to create a new {resource}"

  # READ (single) - GET /resources/{id}
  read:
    method: GET
    path_pattern: "/{resources}/{resourceId}"
    success_response:
      code: 200
      description: Resource retrieved successfully
      body: Resource object
    error_responses: [404, 500]

  # READ (list) - GET /resources
  list:
    method: GET
    path_pattern: "/{resources}"
    success_response:
      code: 200
      description: Paginated list of resources
      body: List response with items array
    error_responses: [400, 500]
    parameters: See list_endpoints section

  # UPDATE - PATCH /resources/{id}
  update:
    method: PATCH
    path_pattern: "/{resources}/{resourceId}"
    success_response:
      code: 200
      description: Resource updated successfully
      body: Updated resource object
    error_responses: [400, 404, 422, 500]
    request_body:
      required: true
      schema_suffix: Update
      description: "Partial update payload for {resource}"

  # DELETE - DELETE /resources/{id}
  delete:
    method: DELETE
    path_pattern: "/{resources}/{resourceId}"
    success_response:
      code: 204
      description: Resource deleted successfully
      body: null
    error_responses: [404, 500]

# =============================================================================
# Shared Components [BOTH]
# =============================================================================
# Error responses are shared. Query parameters are System API only.
# Process APIs define their own request/response DTOs.
shared_components:
  # Error responses - use $ref to these
  error_responses:
    400:
      ref: "./components/common-responses.yaml#/BadRequest"
      description: Invalid request parameters or body
    404:
      ref: "./components/common-responses.yaml#/NotFound"
      description: Resource not found
    422:
      ref: "./components/common-responses.yaml#/UnprocessableEntity"
      description: Request body failed validation
    500:
      ref: "./components/common-responses.yaml#/InternalError"
      description: Unexpected server error

  # Query parameters - use $ref to these
  parameters:
    search:
      ref: "./components/common-parameters.yaml#/SearchQueryParam"
    limit:
      ref: "./components/common-parameters.yaml#/LimitParam"
    offset:
      ref: "./components/common-parameters.yaml#/OffsetParam"

  # Reusable schemas - import and reference as needed
  reusable_schemas:
    - ref: "./components/common.yaml#/Address"
      description: Physical mailing address
      fields: [addressLine1, addressLine2, city, stateProvince, postalCode, county]
    - ref: "./components/common.yaml#/Name"
      description: Person's name
      fields: [firstName, middleInitial, middleName, lastName, maidenName]
    - ref: "./components/common.yaml#/PhoneNumber"
      description: Phone number with regex validation
      pattern: '^\+?[0-9 .\-()]{7,20}$'
    - ref: "./components/common.yaml#/Email"
      description: Email address
      format: email
      maxLength: 320

# =============================================================================
# Schema Patterns [SYSTEM, PROCESS*]
# =============================================================================
# System APIs: Use resource schemas with standard base fields (id, createdAt, updatedAt)
# Process APIs: Use purpose-built DTOs (Request/Response suffixes) - may reference
#               System API schemas but define their own request/response shapes.
schema_patterns:
  # Every resource should have these standard fields
  resource_base_fields:
    - name: id
      type: string
      format: uuid
      readOnly: true
      description: Unique identifier (server-generated)
    - name: createdAt
      type: string
      format: date-time
      readOnly: true
      description: Timestamp when resource was created
    - name: updatedAt
      type: string
      format: date-time
      readOnly: true
      description: Timestamp when resource was last updated

  # Common field patterns
  common_fields:
    # Dates
    date_of_birth:
      type: string
      format: date
      example: "1990-05-15"

    # SSN (optional, sensitive)
    social_security_number:
      type: string
      pattern: '^\d{3}-\d{2}-\d{4}$'
      example: "123-45-6789"

    # Money/currency
    monetary_amount:
      type: number
      minimum: 0
      description: Amount in dollars
      example: 1500.00

    # Status enums
    status_pattern:
      type: string
      enum: Define allowed values
      description: Current status of the resource

  # Schema variants for CRUD
  schema_variants:
    base:
      description: Full resource schema with all fields
      suffix: ""
    create:
      description: Schema for POST requests (excludes readOnly fields)
      suffix: Create
    update:
      description: Schema for PATCH requests (all fields optional except id)
      suffix: Update
    list:
      description: Response schema for GET collection endpoints
      suffix: List

# =============================================================================
# File Structure [BOTH]
# =============================================================================
# System APIs in openapi/domains/, Process APIs in openapi/processes/
file_structure:
  # Main API specs go in openapi/ root
  api_specs:
    location: "openapi/"
    pattern: "{resource-plural}.yaml"
    examples:
      - openapi/persons.yaml
      - openapi/applications.yaml
      - openapi/households.yaml

  # Shared components in openapi/components/
  components:
    location: "openapi/components/"
    files:
      - common.yaml: Reusable schemas (Address, Name, etc.)
      - common-parameters.yaml: Shared query parameters
      - common-responses.yaml: Shared error responses
      - "{resource}.yaml": Resource-specific schemas

  # Example data in openapi/examples/
  examples:
    location: "openapi/examples/"
    pattern: "{resource-plural}.yaml"
    format: |
      {ResourceName}Example1:
        id: "uuid-here"
        field1: "value1"
        # ... all required fields

  # Generated clients
  generated:
    zodios_clients: "generated/clients/zodios/"
    postman_collection: "generated/postman-collection.json"

# =============================================================================
# Process API Metadata [PROCESS]
# =============================================================================
# STATUS: Not yet implemented in validation
# Process APIs use OpenAPI extension fields to declare metadata about
# who can call them and what capability they provide.
process_api_metadata:
  description: |
    Process APIs are organized by domain, then resource, then action:

      /processes/{domain}/{resource}/{action}

    Examples:
      /processes/workflow/tasks/claim
      /processes/workflow/verification/start
      /processes/case-management/workers/assign
      /processes/communication/notices/send

    This enables documentation generation, authorization rules, and API discovery.

  path_convention:
    pattern: "/processes/{domain}/{resource}/{action}"
    components:
      domain: The owning domain (workflow, case-management, intake, eligibility, communication, etc.)
      resource: The resource being acted upon (tasks, workers, cases, notices, etc.)
      action: The operation being performed (claim, assign, transfer, send, etc.)
    convention: |
      When an operation involves multiple resources, place it under the resource
      being acted upon (not the primary output). This matches natural language
      and improves discoverability.
    examples:
      - path: /processes/workflow/tasks/claim
        description: Claim a task (task is acted upon)
      - path: /processes/case-management/workers/assign
        description: Assign a worker (worker is acted upon)
      - path: /processes/case-management/cases/transfer
        description: Transfer a case (case is acted upon)
      - path: /processes/communication/notices/send
        description: Send a notice (notice is acted upon)

  extensions:
    x-actors:
      description: Which actors/roles can call this endpoint
      type: array
      location: Operation level (under paths/{path}/{method})
      values:
        - client              # Person applying for/receiving benefits
        - authorized_rep      # Representative acting on behalf of client
        - caseworker          # Staff processing applications
        - supervisor          # Team lead with approval authority
        - system              # Automated/batch processes
      example: |
        paths:
          /processes/intake/applications/submit:
            post:
              x-actors: [client, caseworker, authorized_rep]
              summary: Submit an application

    x-capability:
      description: The business capability this endpoint provides
      type: string
      location: Operation level (under paths/{path}/{method})
      purpose: |
        Groups related Process API endpoints for documentation and discovery.
        Should match the domain in the Process API path for consistency.
      values:
        # Core domains
        - client-management       # Managing client records and relationships
        - intake                  # Submitting and managing applications
        - eligibility             # Determining eligibility
        - workflow                # Tasks, verification, SLA tracking
        - case-management         # Cases, assignments, workload
        - scheduling              # Appointments and interviews
        - document-management     # Uploading and managing documents
        # Cross-cutting
        - communication           # Notices and correspondence
        - reporting               # Generating reports
        - configuration           # Managing system configuration
      note: |
        The x-capability should match the {domain} segment in the Process API path.
        Example: /processes/workflow/tasks/claim uses x-capability: workflow
      example: |
        paths:
          /processes/intake/applications/submit:
            post:
              x-capability: intake
              x-actors: [client, caseworker]

    x-idempotent:
      description: Whether this operation is idempotent (safe to retry)
      type: boolean
      location: Operation level
      default: false for POST
      note: All Process API POST operations should specify this explicitly
      example: |
        paths:
          /processes/intake/applications/submit:
            post:
              x-idempotent: true  # Safe to retry with same Idempotency-Key

  usage_in_authorization: |
    The x-actors extension can be used by API gateways or middleware to
    enforce role-based access control:
    1. Extract user's role from JWT token
    2. Check if role is in x-actors array for the endpoint
    3. Return 403 Forbidden if not authorized

  usage_in_documentation: |
    Documentation generators can use these extensions to:
    - Group endpoints by x-capability
    - Show which roles can access each endpoint
    - Generate role-specific API documentation

# =============================================================================
# Validation Rules [BOTH]
# =============================================================================
# Syntax and lint rules apply to both. Pattern checks differ by API type.
validation:
  # These are enforced by npm run validate
  layers:
    - name: syntax
      command: "npm run validate:syntax"
      checks:
        - OpenAPI 3.1 compliance
        - All $ref references resolve
        - Examples match schemas
    - name: lint
      command: "npm run validate:lint"
      checks:
        - Naming conventions (paths, operations, schemas)
        - Response codes (POST→201, DELETE→204)
        - Content types (application/json)
    - name: patterns
      command: "npm run validate:patterns"
      checks:
        - List endpoints have search/pagination params
        - List responses have required properties
        - Error responses use shared $refs
        - CRUD operations follow patterns

# =============================================================================
# Error Handling [BOTH]
# =============================================================================
# STATUS: Not yet implemented in mock server or validation
error_handling:
  # Standard error response body structure
  response_body:
    required_fields:
      - name: code
        type: string
        description: Machine-readable error code (e.g., "VALIDATION_ERROR", "RESOURCE_NOT_FOUND")
      - name: message
        type: string
        description: Human-readable error description
    optional_fields:
      - name: details
        type: array
        description: Array of specific field-level errors
        items:
          field: Path to the field with error
          code: Field-specific error code
          message: Field-specific error message
      - name: retryable
        type: boolean
        description: Whether the client should retry the request
      - name: retryAfter
        type: integer
        description: Seconds to wait before retry (for rate limiting)

  # Error code taxonomy
  error_codes:
    validation:
      - MISSING_REQUIRED_FIELD
      - INVALID_FORMAT
      - INVALID_VALUE
      - VALUE_OUT_OF_RANGE
      - FIELD_TOO_LONG
    business_rules:
      - DUPLICATE_RESOURCE
      - INVALID_STATE_TRANSITION
      - PREREQUISITE_NOT_MET
      - RESOURCE_LOCKED
      - SLA_CONSTRAINT_VIOLATED
    authorization:
      - UNAUTHORIZED
      - FORBIDDEN
      - INSUFFICIENT_PERMISSIONS
    system:
      - SERVICE_UNAVAILABLE
      - UPSTREAM_TIMEOUT
      - INTERNAL_ERROR

  # HTTP status code guidance
  http_status_guidance:
    400:
      description: Malformed request (can't parse JSON, missing required query params)
      retryable: false
    401:
      description: Authentication required or invalid credentials
      retryable: false
    403:
      description: Authenticated but not authorized for this resource/action
      retryable: false
    404:
      description: Resource not found
      retryable: false
    409:
      description: Conflict (duplicate resource, concurrent modification)
      retryable: true
      note: Client should fetch current state and retry
    422:
      description: Valid JSON but fails business validation
      retryable: false
    429:
      description: Rate limited
      retryable: true
      note: Use retryAfter header
    500:
      description: Unexpected server error
      retryable: true
    503:
      description: Service temporarily unavailable
      retryable: true

# =============================================================================
# API Versioning [BOTH]
# =============================================================================
# STATUS: Not yet implemented
versioning:
  strategy: url-path
  description: Version in URL path (e.g., /v1/tasks, /v2/tasks)

  current_version: v1
  supported_versions:
    - v1

  compatibility_rules:
    backward_compatible:
      - Adding new optional request fields
      - Adding new response fields
      - Adding new endpoints
      - Adding new enum values (clients must ignore unknown values)
      - Adding new optional query parameters
    breaking_changes:
      - Removing fields
      - Changing field types
      - Renaming fields
      - Removing enum values
      - Changing URL paths
      - Making optional fields required

  deprecation:
    notice_period_months: 6
    headers:
      - name: Deprecation
        value: "true"
        description: Indicates endpoint is deprecated
      - name: Sunset
        value: "<ISO 8601 date>"
        description: Date when endpoint will be removed
      - name: Link
        value: "<url>; rel=\"successor-version\""
        description: Link to replacement endpoint/documentation

# =============================================================================
# Idempotency [PROCESS required, SYSTEM for POST only]
# =============================================================================
# STATUS: Not yet implemented in mock server
# Process APIs: Required for all POST operations (actions may have side effects)
# System APIs: Required for POST (create) operations only
idempotency:
  description: |
    Ensures that retrying a request (due to network issues, timeouts, etc.)
    does not cause duplicate side effects. Critical for Process APIs.

  applies_to:
    process_apis: All POST operations (required)
    system_apis: POST operations that create resources

  mechanism:
    header_name: Idempotency-Key
    format: Client-generated UUID v4
    required: true for applicable operations
    behavior: |
      1. Client generates unique key and includes in request header
      2. Server checks if key has been seen within retention window
      3. If seen: return stored response (do not re-execute)
      4. If new: execute operation, store response with key
    retention_hours: 24
    note: Keys are scoped per client/tenant

  response_headers:
    - name: Idempotent-Replayed
      values: ["true", "false"]
      description: Indicates whether this response is a replay of a previous request

  error_cases:
    - code: IDEMPOTENCY_KEY_REUSED
      status: 422
      description: Same key used with different request body
    - code: IDEMPOTENCY_KEY_MISSING
      status: 400
      description: Required idempotency key not provided

# =============================================================================
# Batch Operations [SYSTEM primarily, PROCESS rarely]
# =============================================================================
# STATUS: Not yet implemented
# System APIs: Common for bulk CRUD (e.g., PATCH /tasks/batch)
# Process APIs: Rare; most process operations are single-action. If needed,
#               the process itself handles multiple items (e.g., bulk-reassign).
batch_operations:
  description: |
    For operations that need to affect multiple resources in a single request.
    Useful for bulk updates, imports, and administrative operations.
    Primarily for System APIs; Process APIs typically handle batching internally.

  endpoint_pattern: "/{resources}/batch"
  method: POST

  request_body:
    structure:
      operations:
        type: array
        max_items: 100
        items:
          action:
            type: string
            enum: [create, update, delete]
          id:
            type: string
            description: Required for update/delete, omit for create
          data:
            type: object
            description: Resource payload (for create/update)

  response:
    structure:
      total: Total operations requested
      succeeded: Count of successful operations
      failed: Count of failed operations
      results:
        type: array
        items:
          index: Position in request array
          action: The action attempted
          status: "succeeded" | "failed"
          id: Resource ID (for successful creates)
          error: Error details (for failures)

  behavior:
    atomicity: false
    description: |
      Batch operations use partial success model - individual operations
      may succeed or fail independently. Client must check results array
      to determine outcome of each operation.
    ordering: Operations processed sequentially in array order
    rate_limiting: Batch counts as N requests toward rate limit

  idempotency:
    description: Batch operations require idempotency key
    scope: Entire batch (not individual operations)

# =============================================================================
# Authentication [BOTH]
# =============================================================================
# STATUS: Not yet implemented
# NOTE: States will use their own identity providers. This section defines the
#       interface contract, not the specific provider implementation.
authentication:
  description: |
    How clients prove their identity. The API layer validates tokens but does
    not implement the identity provider - that's state-specific infrastructure.

  # Supported authentication methods (state chooses which to implement)
  supported_methods:
    oauth2_oidc:
      description: OAuth 2.0 with OpenID Connect (recommended for user-facing apps)
      token_type: Bearer
      header: "Authorization: Bearer <token>"
      token_format: JWT (recommended) or opaque
      discovery: "/.well-known/openid-configuration"
      note: State configures their IdP (Okta, Azure AD, Auth0, state-specific)

    api_key:
      description: API keys for server-to-server integration
      header: "X-API-Key: <key>"
      use_cases:
        - Batch jobs
        - Legacy system integration
        - Internal service-to-service
      note: Simpler but less secure; use OAuth for user context

    mtls:
      description: Mutual TLS with client certificates
      use_cases:
        - High-security integrations
        - Federal system connections
      note: Certificate management is state responsibility

  # OpenAPI security scheme definitions (for spec files)
  openapi_security_schemes:
    bearerAuth:
      type: http
      scheme: bearer
      bearerFormat: JWT
      description: OAuth 2.0 Bearer token

    apiKeyAuth:
      type: apiKey
      in: header
      name: X-API-Key
      description: API key for server-to-server calls

  # Token validation requirements
  token_validation:
    required_claims:
      - sub: Subject (user or service identifier)
      - iat: Issued at timestamp
      - exp: Expiration timestamp
    recommended_claims:
      - iss: Issuer (IdP identifier)
      - aud: Audience (this API)
      - scope: OAuth scopes granted
      - roles: User roles (for RBAC)
      - tenant_id: State/county identifier (if multi-tenant)

  # State configuration guidance
  state_configuration:
    description: |
      Each state configures their identity provider. The API layer needs:
      - JWKS endpoint (for JWT validation)
      - Issuer URL (for token verification)
      - Audience value (this API's identifier)
      - Clock skew tolerance
    environment_variables:
      - AUTH_JWKS_URI: "https://idp.example.gov/.well-known/jwks.json"
      - AUTH_ISSUER: "https://idp.example.gov"
      - AUTH_AUDIENCE: "safety-net-api"
      - AUTH_CLOCK_SKEW_SECONDS: 60

# =============================================================================
# Authorization [BOTH]
# =============================================================================
# STATUS: Not yet implemented
# NOTE: Authorization rules may vary by state. This defines the patterns;
#       specific role definitions are state-configurable.
authorization:
  description: |
    What authenticated users can do. Combines role-based access control (RBAC)
    with attribute-based rules (ABAC) for fine-grained permissions.

  # OAuth scopes (coarse-grained API access)
  scopes:
    description: OAuth scopes control broad API access categories
    standard_scopes:
      - name: "applications:read"
        description: Read applications
      - name: "applications:write"
        description: Create/update applications
      - name: "tasks:read"
        description: Read tasks
      - name: "tasks:write"
        description: Update task status, assignments
      - name: "cases:read"
        description: Read case information
      - name: "cases:write"
        description: Update cases
      - name: "config:read"
        description: Read configuration
      - name: "config:admin"
        description: Modify configuration (admin only)
      - name: "audit:read"
        description: Read audit logs

  # Role-based access control
  rbac:
    description: |
      Roles provide bundles of permissions. Roles are state-configurable but
      should follow this general hierarchy.
    standard_roles:
      - name: client
        description: Person applying for/receiving benefits
        typical_scopes: [applications:read, applications:write]
        constraints: Own data only

      - name: authorized_representative
        description: Representative acting on behalf of clients
        typical_scopes: [applications:read, applications:write]
        constraints: Delegated clients only

      - name: caseworker
        description: Staff processing applications and tasks
        typical_scopes: [applications:read, tasks:read, tasks:write, cases:read]
        constraints: Assigned work only

      - name: supervisor
        description: Team lead with approval authority
        typical_scopes: [applications:read, tasks:read, tasks:write, cases:read, cases:write]
        constraints: Team's work, can reassign

      - name: office_manager
        description: Office-level administration
        typical_scopes: [applications:read, tasks:read, cases:read, config:read]
        constraints: Office scope

      - name: program_admin
        description: Program configuration and reporting
        typical_scopes: [config:read, config:admin, audit:read]
        constraints: No case-level PII access

      - name: auditor
        description: Read-only access for compliance review
        typical_scopes: [applications:read, tasks:read, cases:read, audit:read]
        constraints: Read-only, all data

    state_customization: |
      States may define additional roles or modify scope assignments.
      Role names should remain consistent for interoperability.

  # Attribute-based access control
  abac:
    description: |
      Fine-grained rules based on resource and user attributes.
      Evaluated after RBAC role check passes.
    example_rules:
      - rule: "Caseworker can only access assigned cases"
        condition: "resource.assignedToId == user.id"

      - rule: "Supervisor can access team's cases"
        condition: "resource.assignedToId IN user.teamMemberIds"

      - rule: "Office manager can access office's cases"
        condition: "resource.officeId == user.officeId"

      - rule: "Can only view cases for programs user is certified for"
        condition: "resource.programType IN user.certifiedPrograms"

  # Field-level authorization
  field_level:
    description: |
      Some fields require additional authorization beyond endpoint access.
      Same endpoint may return different fields based on role.
    sensitive_fields:
      - field: socialSecurityNumber
        full_access: [auditor, assigned_caseworker_during_verification]
        masked_access: [supervisor, office_manager]  # Last 4 only
        no_access: [client]  # Cannot see own SSN in API response

      - field: internalNotes
        full_access: [caseworker, supervisor]
        no_access: [client, authorized_representative]

    implementation: |
      Use response filtering at the API layer. Do not rely on clients
      to hide fields - the API must not return unauthorized data.

# =============================================================================
# Rate Limiting [BOTH]
# =============================================================================
# STATUS: Not yet implemented
rate_limiting:
  description: |
    Protects the API from abuse and ensures fair resource allocation.
    Typically implemented at API gateway level.

  # Standard headers
  headers:
    - name: X-RateLimit-Limit
      description: Maximum requests allowed in window
    - name: X-RateLimit-Remaining
      description: Requests remaining in current window
    - name: X-RateLimit-Reset
      description: Unix timestamp when window resets
    - name: Retry-After
      description: Seconds to wait before retrying (on 429 response)

  # Rate limit tiers (state-configurable)
  default_tiers:
    - tier: standard
      requests_per_minute: 60
      requests_per_hour: 1000
      applies_to: Default for authenticated users

    - tier: elevated
      requests_per_minute: 300
      requests_per_hour: 5000
      applies_to: Trusted internal services

    - tier: batch
      requests_per_minute: 10
      requests_per_hour: 100
      note: Batch endpoints; each batch counts as N requests

  # Response when rate limited
  rate_limit_response:
    status: 429
    body:
      code: RATE_LIMIT_EXCEEDED
      message: Too many requests
      retryAfter: <seconds>

# =============================================================================
# Security Headers [BOTH]
# =============================================================================
# STATUS: Not yet implemented
security_headers:
  description: Standard HTTP security headers for all responses

  required_headers:
    - name: Strict-Transport-Security
      value: "max-age=31536000; includeSubDomains"
      description: Enforce HTTPS

    - name: X-Content-Type-Options
      value: "nosniff"
      description: Prevent MIME type sniffing

    - name: X-Frame-Options
      value: "DENY"
      description: Prevent clickjacking

    - name: Cache-Control
      value: "no-store"
      description: Prevent caching of sensitive data
      note: May be relaxed for public/static endpoints

  cors:
    description: Cross-Origin Resource Sharing (state-configurable)
    configuration:
      allowed_origins: State configures allowed frontend domains
      allowed_methods: [GET, POST, PATCH, DELETE, OPTIONS]
      allowed_headers: [Authorization, Content-Type, X-API-Key, Idempotency-Key]
      expose_headers: [X-RateLimit-Limit, X-RateLimit-Remaining, X-RateLimit-Reset]
      max_age: 86400

# =============================================================================
# Audit Logging [BOTH]
# =============================================================================
# STATUS: Not yet implemented
audit_logging:
  description: |
    All API access must be logged for compliance and security monitoring.
    Logs must NOT contain PII - use correlation IDs to link to secure storage.

  required_fields:
    - timestamp: ISO 8601 format
    - correlation_id: Request correlation ID
    - user_id: Authenticated user identifier
    - user_role: Role used for this request
    - client_ip: Originating IP address
    - method: HTTP method
    - path: Request path (without query params)
    - resource_type: Type of resource accessed
    - resource_id: ID of resource accessed (if applicable)
    - action: Logical action (create, read, update, delete)
    - status_code: HTTP response status
    - response_time_ms: Request duration

  sensitive_access_logging:
    description: Additional logging for sensitive data access
    triggers:
      - SSN viewed (even read access)
      - PII exported
      - Bulk data access
      - Configuration changes
      - Failed authorization attempts
    additional_fields:
      - fields_accessed: Which sensitive fields were returned
      - business_justification: If provided by user
      - supervisor_notified: For break-glass access

  pii_handling:
    description: Never log PII directly
    guidance:
      - Log resource IDs, not resource content
      - Log field names accessed, not field values
      - Use correlation ID to link to audit detail in secure storage
      - Mask any PII that must appear in logs (e.g., last 4 of SSN)

# =============================================================================
# Correlation IDs [BOTH]
# =============================================================================
# STATUS: Not yet implemented
correlation_ids:
  description: |
    Unique identifier that follows a request through all services and logs.
    Essential for distributed tracing and debugging.

  header:
    name: X-Correlation-ID
    format: UUID v4
    behavior: |
      1. If client provides X-Correlation-ID, use it
      2. If not provided, generate a new UUID
      3. Include in all downstream service calls
      4. Include in all log entries
      5. Return in response header

  response_header:
    name: X-Correlation-ID
    description: Echo back the correlation ID used for this request

  logging_integration:
    description: All log entries must include correlationId field
    example: |
      {
        "timestamp": "2024-01-15T10:30:00Z",
        "level": "info",
        "correlationId": "550e8400-e29b-41d4-a716-446655440000",
        "service": "task-api",
        "message": "Task created",
        "taskId": "abc-123"
      }

  propagation:
    description: Pass correlation ID to all downstream calls
    guidance:
      - Include X-Correlation-ID header in HTTP calls to other services
      - Include in message queue message headers
      - Include in async job metadata

# =============================================================================
# ETags and Optimistic Concurrency [SYSTEM]
# =============================================================================
# STATUS: Not yet implemented
etags:
  description: |
    ETags enable optimistic concurrency control (prevent lost updates) and
    conditional requests (caching). System APIs should support ETags for
    resources that can be updated.

  response_headers:
    ETag:
      description: Opaque identifier for the current resource version
      format: Quoted string (e.g., "abc123" or W/"abc123" for weak)
      generation: Hash of resource content or version number

  request_headers:
    If-Match:
      description: Update only if ETag matches (optimistic locking)
      use_case: Prevent lost updates when multiple users edit same resource
      behavior: |
        1. Client GETs resource, receives ETag
        2. Client PATCHes with If-Match: "etag-value"
        3. If ETag matches current: apply update, return new ETag
        4. If ETag doesn't match: return 412 Precondition Failed

    If-None-Match:
      description: Return resource only if ETag differs (caching)
      use_case: Avoid re-downloading unchanged resources
      behavior: |
        1. Client GETs resource, caches response with ETag
        2. Client GETs again with If-None-Match: "etag-value"
        3. If ETag matches: return 304 Not Modified (no body)
        4. If ETag differs: return 200 with new resource and ETag

  error_responses:
    412:
      code: PRECONDITION_FAILED
      description: If-Match ETag doesn't match current version
      message: Resource has been modified by another request
      guidance: Client should re-fetch and retry or notify user of conflict

    304:
      description: Not Modified - resource unchanged since ETag
      body: Empty (client uses cached version)

  implementation_notes:
    - ETags should be opaque to clients (don't expose version numbers directly)
    - Use strong ETags for byte-for-byte comparison
    - Use weak ETags (W/"...") for semantic equivalence
    - Consider ETag scope: entire resource or specific fields

# =============================================================================
# Sorting [SYSTEM]
# =============================================================================
# STATUS: Not yet implemented
sorting:
  description: |
    Standard query parameter for sorting list endpoint results.
    Sorting is typically used with System APIs that return collections.

  parameter:
    name: sort
    location: query
    type: string
    description: |
      Comma-separated list of fields to sort by. Prefix with - for descending.
      First field is primary sort, subsequent fields are secondary sorts.

  syntax:
    ascending: "fieldName"
    descending: "-fieldName"
    multiple: "field1,-field2,field3"

  examples:
    - sort=createdAt           # Oldest first
    - sort=-createdAt          # Newest first
    - sort=status,-priority    # By status (asc), then priority (desc)
    - sort=-dueDate,createdAt  # By due date (desc), then created (asc)

  default_behavior:
    description: If no sort specified, use sensible default per resource
    typical_defaults:
      - List endpoints: -createdAt (newest first)
      - Search results: relevance score (if applicable)

  error_handling:
    invalid_field:
      status: 400
      code: INVALID_SORT_FIELD
      message: "Unknown sort field: {field}"
    unsortable_field:
      status: 400
      code: FIELD_NOT_SORTABLE
      message: "Field '{field}' does not support sorting"

  implementation_notes:
    - Document sortable fields in OpenAPI spec
    - Consider index implications for sortable fields
    - Limit number of sort fields (e.g., max 3)

# =============================================================================
# Long-Running Operations [PROCESS primarily]
# =============================================================================
# STATUS: Not yet implemented
long_running_operations:
  description: |
    Pattern for operations that take too long for a synchronous response.
    Common in Process APIs for complex business operations (e.g., batch
    eligibility determination, bulk document processing).

  threshold:
    description: Operations expected to take >30 seconds should be async
    note: Exact threshold depends on client requirements and infrastructure

  pattern:
    name: Polling with Operation Resource
    flow: |
      1. Client POSTs to initiate operation
      2. Server returns 202 Accepted with operation ID and status URL
      3. Client polls status URL until complete
      4. When complete, status includes result or result URL

  initiation:
    request:
      method: POST
      path: "/processes/{domain}/{resource}/{action}"
      body: Operation parameters
      headers:
        Idempotency-Key: Required (operations are idempotent)

    response:
      status: 202 Accepted
      headers:
        Location: URL to poll for status
      body:
        operationId: UUID
        status: "pending" | "running"
        statusUrl: "/operations/{operationId}"
        estimatedCompletionTime: ISO 8601 datetime (optional)

  status_polling:
    request:
      method: GET
      path: "/operations/{operationId}"

    response_pending:
      status: 200
      body:
        operationId: UUID
        status: "pending" | "running"
        progress: 0-100 (optional)
        message: Human-readable status (optional)

    response_completed:
      status: 200
      body:
        operationId: UUID
        status: "completed"
        completedAt: ISO 8601 datetime
        result: Inline result (if small)
        resultUrl: URL to fetch result (if large)

    response_failed:
      status: 200
      body:
        operationId: UUID
        status: "failed"
        error:
          code: Error code
          message: Error description
        failedAt: ISO 8601 datetime

  cancellation:
    description: Allow clients to cancel long-running operations
    request:
      method: DELETE
      path: "/operations/{operationId}"
    response:
      status: 200 (cancelled) or 409 (cannot cancel - already complete)

  polling_guidance:
    initial_delay: 1 second
    max_delay: 30 seconds
    backoff: Exponential with jitter
    note: Include Retry-After header in status responses

  alternative_patterns:
    webhooks:
      description: Server calls client webhook when complete
      trade_off: More complex but avoids polling overhead
    server_sent_events:
      description: Client maintains connection for real-time updates
      trade_off: More complex, connection management issues
